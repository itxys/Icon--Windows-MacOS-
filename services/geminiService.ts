
import { GoogleGenAI } from "@google/genai";
import { GeneratedImage, AIConfig } from "../types";

const defaultGeminiKey = process.env.API_KEY || '';

const generateWithGemini = async (prompt: string, apiKey: string): Promise<GeneratedImage> => {
  const keyToUse = apiKey || defaultGeminiKey;
  
  if (!keyToUse) {
    throw new Error("API Key is missing. Please provide a Google Gemini API Key in settings.");
  }

  const ai = new GoogleGenAI({ apiKey: keyToUse });
  const model = 'gemini-2.5-flash-image';
  
  try {
    const response = await ai.models.generateContent({
      model,
      contents: {
        parts: [
          {
            text: `Generate a high-quality, professional, centered app icon for: ${prompt}. Minimalist, vector style, white background, suitable for a computer icon.`,
          },
        ],
      },
    });

    let generatedImage: GeneratedImage | null = null;

    if (response.candidates?.[0]?.content?.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
           generatedImage = {
             base64: part.inlineData.data,
             mimeType: part.inlineData.mimeType || 'image/png',
             url: `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`
           };
           break;
        }
      }
    }

    if (!generatedImage) {
      throw new Error("No image was generated by the Gemini model.");
    }

    return generatedImage;

  } catch (error: any) {
    console.error("Gemini Image Generation Error:", error);
    throw new Error(error.message || "Failed to generate icon with Gemini.");
  }
};

const generateWithOpenAI = async (prompt: string, apiKey: string): Promise<GeneratedImage> => {
  if (!apiKey) {
    throw new Error("API Key is missing. Please provide an OpenAI API Key in settings.");
  }

  try {
    const response = await fetch('https://api.openai.com/v1/images/generations', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: `App icon for: ${prompt}. Minimalist, vector style, white background.`,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error?.message || `OpenAI Error: ${response.statusText}`);
    }

    const data = await response.json();
    const image = data.data?.[0];

    if (!image || !image.b64_json) {
      throw new Error("No image data received from OpenAI.");
    }

    return {
      base64: image.b64_json,
      mimeType: 'image/png',
      url: `data:image/png;base64,${image.b64_json}`
    };

  } catch (error: any) {
    console.error("OpenAI Image Generation Error:", error);
    throw new Error(error.message || "Failed to generate icon with OpenAI.");
  }
};

const generateWithDoubao = async (prompt: string, apiKey: string): Promise<GeneratedImage> => {
    if (!apiKey) {
      throw new Error("API Key is missing. Please provide a Volcano Engine (Doubao) API Key.");
    }
  
    // Volcano Engine (Ark) is OpenAI Compatible
    // Endpoint: https://ark.cn-beijing.volces.com/api/v3/images/generations
    try {
      const response = await fetch('https://ark.cn-beijing.volces.com/api/v3/images/generations', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: "doubao-image-pro-v1", // Default to pro model
          prompt: `App icon for: ${prompt}. Minimalist, vector style, white background.`,
          n: 1,
          size: "512x512", // Doubao supports 512x512
          response_format: "b64_json"
        })
      });
  
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error?.message || `Doubao Error: ${response.status} ${response.statusText}`);
      }
  
      const data = await response.json();
      const image = data.data?.[0];
  
      if (!image || !image.b64_json) {
        throw new Error("No image data received from Doubao.");
      }
  
      return {
        base64: image.b64_json,
        mimeType: 'image/png',
        url: `data:image/png;base64,${image.b64_json}`
      };
  
    } catch (error: any) {
      console.error("Doubao Image Generation Error:", error);
      throw new Error(error.message || "Failed to generate icon with Doubao.");
    }
  };

  const generateWithQwen = async (prompt: string, apiKey: string): Promise<GeneratedImage> => {
    if (!apiKey) {
      throw new Error("API Key is missing. Please provide an Alibaba Cloud (DashScope) API Key.");
    }
  
    // Alibaba DashScope API (Asynchronous)
    // 1. Submit Task
    try {
      const submitResponse = await fetch('https://dashscope.aliyuncs.com/api/v1/services/aigc/text2image/image-synthesis', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'X-DashScope-Async': 'enable'
        },
        body: JSON.stringify({
          model: "wanx-v1",
          input: {
            prompt: `App icon for: ${prompt}. Minimalist, vector style, white background.`
          },
          parameters: {
            size: "1024*1024",
            n: 1
          }
        })
      });
  
      if (!submitResponse.ok) {
         const errorData = await submitResponse.json().catch(() => ({}));
         throw new Error(errorData.message || `Qwen Submit Error: ${submitResponse.status}`);
      }
  
      const submitData = await submitResponse.json();
      const taskId = submitData.output?.task_id;
  
      if (!taskId) {
        throw new Error("Failed to get Task ID from Qwen.");
      }
  
      // 2. Poll for status
      let attempts = 0;
      const maxAttempts = 30; // 60 seconds roughly
      let imageUrl = '';
  
      while (attempts < maxAttempts) {
        await new Promise(r => setTimeout(r, 2000)); // Wait 2s
        attempts++;
  
        const statusResponse = await fetch(`https://dashscope.aliyuncs.com/api/v1/tasks/${taskId}`, {
          headers: { 'Authorization': `Bearer ${apiKey}` }
        });
  
        if (!statusResponse.ok) continue;
  
        const statusData = await statusResponse.json();
        const taskStatus = statusData.output?.task_status;
  
        if (taskStatus === 'SUCCEEDED') {
           imageUrl = statusData.output?.results?.[0]?.url;
           break;
        } else if (taskStatus === 'FAILED' || taskStatus === 'CANCELED') {
           throw new Error(`Qwen Task Failed: ${statusData.output?.message || 'Unknown error'}`);
        }
      }
  
      if (!imageUrl) {
        throw new Error("Qwen generation timed out or returned no image.");
      }
  
      // 3. Fetch image and convert to Base64 (to avoid CORS issues later in canvas)
      // Note: We perform this fetch from client-side. DashScope URLs typically support CORS.
      const imageFetch = await fetch(imageUrl);
      const imageBlob = await imageFetch.blob();
      
      return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
              if (typeof reader.result === 'string') {
                  // reader.result includes "data:image/png;base64,..."
                  const base64 = reader.result.split(',')[1];
                  resolve({
                      base64: base64,
                      mimeType: imageBlob.type,
                      url: reader.result
                  });
              } else {
                  reject(new Error("Failed to convert Qwen image to base64"));
              }
          };
          reader.onerror = reject;
          reader.readAsDataURL(imageBlob);
      });
  
    } catch (error: any) {
      console.error("Qwen Image Generation Error:", error);
      throw new Error(error.message || "Failed to generate icon with Qwen.");
    }
  };

export const generateIcon = async (prompt: string, config: AIConfig): Promise<GeneratedImage> => {
  switch (config.provider) {
    case 'openai':
      return generateWithOpenAI(prompt, config.apiKey);
    case 'doubao':
      return generateWithDoubao(prompt, config.apiKey);
    case 'qwen':
      return generateWithQwen(prompt, config.apiKey);
    case 'gemini':
    default:
      return generateWithGemini(prompt, config.apiKey);
  }
};
